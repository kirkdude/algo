# swanctl.conf for strongSwan 6.0+ post-quantum VPN
# Generated by Algo VPN quantum-safe role

connections {
{% if quantum_safe_mode in ['hybrid', 'pure_pq'] %}
    # Primary post-quantum connection
    algo-pq {
        version = 2

        # Post-quantum proposals
{% if quantum_safe_mode == 'hybrid' %}
        proposals = {{ ciphers.quantum_safe.hybrid.ike }}
{% else %}
        proposals = {{ ciphers.quantum_safe.pure_pq.ike }}
{% endif %}
        esp_proposals = {{ ciphers.quantum_safe.hybrid.esp }}

        # Connection parameters
        reauth_time = 12h
        life_time = 3h
        rand_time = 1h
        over_time = 10m

        # Fragmentation and compression
        fragmentation = yes
        compress = yes

        # DPD configuration
        dpd_action = clear
        dpd_delay = 35s

        # Local gateway configuration
        local_addrs = %any
        local {
            auth = pubkey
            certs = {{ IP_subject_alt_name }}.crt
            id = {{ IP_subject_alt_name }}
        }

        # Remote client configuration
        remote {
            auth = pubkey
        }

        # Child SA configuration
        children {
            algo-pq-tunnel {
                local_ts = 0.0.0.0/0{% if ipv6_support %}, ::/0{% endif %}

                remote_ts = {{ strongswan_network }}{% if ipv6_support %}, {{ strongswan_network_ipv6 }}{% endif %}

                esp_proposals = {{ ciphers.quantum_safe.hybrid.esp }}
                life_time = 3h
                rand_time = 30m
                dpd_action = clear

                # Enhanced settings for post-quantum
                mode = tunnel
                start_action = none
                close_action = none
            }
        }

        # Post-quantum specific settings
        mobike = no  # Disabled for PQ stability
        unique = never
    }

    # Fallback connection for classical clients
    algo-classical-fallback {
        version = 2
        proposals = {{ ciphers.defaults.ike }}
        esp_proposals = {{ ciphers.defaults.esp }}

        reauth_time = 12h
        life_time = 3h
        fragmentation = yes
        compress = yes
        dpd_action = clear
        dpd_delay = 35s

        local_addrs = %any
        local {
            auth = pubkey
            certs = {{ IP_subject_alt_name }}.crt
            id = {{ IP_subject_alt_name }}
        }

        remote {
            auth = pubkey
        }

        children {
            algo-classical-tunnel {
                local_ts = 0.0.0.0/0{% if ipv6_support %}, ::/0{% endif %}

                remote_ts = {{ strongswan_network }}{% if ipv6_support %}, {{ strongswan_network_ipv6 }}{% endif %}

                esp_proposals = {{ ciphers.defaults.esp }}
                life_time = 3h
                mode = tunnel
                start_action = none
                close_action = none
            }
        }

        unique = never
    }
{% else %}
    # Classical-only connection
    algo-classical {
        version = 2
        proposals = {{ ciphers.defaults.ike }}
        esp_proposals = {{ ciphers.defaults.esp }}

        reauth_time = 12h
        life_time = 3h
        fragmentation = yes
        compress = yes
        dpd_action = clear
        dpd_delay = 35s

        local_addrs = %any
        local {
            auth = pubkey
            certs = {{ IP_subject_alt_name }}.crt
            id = {{ IP_subject_alt_name }}
        }

        remote {
            auth = pubkey
        }

        children {
            algo-tunnel {
                local_ts = 0.0.0.0/0{% if ipv6_support %}, ::/0{% endif %}

                remote_ts = {{ strongswan_network }}{% if ipv6_support %}, {{ strongswan_network_ipv6 }}{% endif %}

                esp_proposals = {{ ciphers.defaults.esp }}
                life_time = 3h
                mode = tunnel
                start_action = none
                close_action = none
            }
        }

        unique = never
    }
{% endif %}
}

# Pool configuration for IP assignment
pools {
    algo-pool-ipv4 {
        addrs = {{ strongswan_network }}
{% if algo_dns_adblocking or dns_encryption %}
        dns = {{ local_service_ip }}
{% else %}
        dns = {% for host in dns_servers.ipv4 %}{{ host }}{% if not loop.last %}, {% endif %}{% endfor %}
{% endif %}
    }

{% if ipv6_support %}
    algo-pool-ipv6 {
        addrs = {{ strongswan_network_ipv6 }}
{% if algo_dns_adblocking or dns_encryption %}
        dns = {{ local_service_ipv6 }}
{% else %}
        dns = {% for host in dns_servers.ipv6 %}{{ host }}{% if not loop.last %}, {% endif %}{% endfor %}
{% endif %}
    }
{% endif %}
}

# Certificate authorities
authorities {
    algo-ca {
        cacert = cacert.pem
        auto = add
    }
}

# Secrets will be loaded from separate files
secrets {
    # Private keys loaded automatically from /etc/swanctl/private/
    # CA certificate loaded from /etc/swanctl/x509ca/
}
